---
- name: Configure WebQuiz Tunnel Server - Multi-User Subdomain Mode
  hosts: localhost
  become: yes
  connection: local

  vars:
    domain_name: webquiz.xyz
    tunnel_socket_dir: /var/run/tunnels
    users_dir: "{{ playbook_dir }}/files/users"
    custom_domains_dir: "{{ playbook_dir }}/files/custom_domains"
    nginx_proxy_timeout: 300
    nginx_websocket_timeout: 3600
    letsencrypt_email: admin@webquiz.xyz
    ssl_cert_path: "/etc/letsencrypt/live/{{ domain_name }}/fullchain.pem"
    www_root: /var/www/html

  tasks:
    - name: Discover user directories
      find:
        paths: "{{ users_dir }}"
        file_type: directory
        recurse: no
      register: user_directories
      delegate_to: localhost
      become: no

    - name: Extract user list from directories
      set_fact:
        tunnel_users: >-
          {{ user_directories.files |
             map(attribute='path') |
             map('basename') |
             list }}

    - name: Display discovered users
      debug:
        msg: "Discovered users: {{ tunnel_users }}"

    - name: Discover custom domain configuration files
      find:
        paths: "{{ custom_domains_dir }}"
        patterns: "*.yml"
        file_type: file
      register: custom_domain_files
      delegate_to: localhost
      become: no

    - name: Read custom domain configurations
      set_fact:
        custom_domains_raw: >-
          {{ custom_domain_files.files |
             map(attribute='path') |
             map('lookup', 'file') |
             map('from_yaml') |
             list }}
      when: custom_domain_files.files | length > 0

    - name: Set empty custom domains raw list if none found
      set_fact:
        custom_domains_raw: []
      when: custom_domain_files.files | length == 0 or custom_domain_files.files is not defined

    - name: Process custom domain configurations with environment variables
      set_fact:
        custom_domains: >-
          {% set result = [] %}
          {% for domain_config in custom_domains_raw %}
          {% set _ = result.append(domain_config | combine({
            'backend_host': lookup('env', domain_config.backend_host_secret) | default(''),
            'backend_port': lookup('env', domain_config.backend_port_secret) | default('')
          })) %}
          {% endfor %}
          {{ result }}

    - name: Display discovered custom domains
      debug:
        msg: "Discovered custom domains: {{ custom_domains | map(attribute='domain') | list }}"

    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install required packages
      apt:
        name:
          - nginx
          - certbot
          - python3-certbot-nginx
          - openssh-server
          - lsof
        state: present

    - name: Create user-specific tunnel accounts
      user:
        name: "{{ item }}"
        shell: /bin/bash
        create_home: yes
        state: present
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0

    - name: Create user-specific socket directories
      file:
        path: "{{ tunnel_socket_dir }}/{{ item }}"
        state: directory
        owner: "{{ item }}"
        group: "{{ item }}"
        mode: '2775'
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0

    - name: Add www-data to user-specific groups
      user:
        name: www-data
        groups: "{{ item }}"
        append: yes
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0
      notify: reload nginx

    - name: Create .ssh directories for users
      file:
        path: "/home/{{ item }}/.ssh"
        state: directory
        owner: "{{ item }}"
        group: "{{ item }}"
        mode: '0700'
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0

    - name: Collect SSH keys for each user
      find:
        paths: "{{ users_dir }}/{{ item }}"
        patterns: "*.pub"
      register: user_ssh_keys
      loop: "{{ tunnel_users }}"
      delegate_to: localhost
      become: no
      when: tunnel_users | length > 0

    - name: Add authorized keys for each user
      authorized_key:
        user: "{{ user_key.0.item }}"
        key: "{{ lookup('file', user_key.1.path) }}"
        state: present
      with_subelements:
        - "{{ user_ssh_keys.results }}"
        - files
      loop_control:
        loop_var: user_key
      when:
        - tunnel_users | length > 0
        - user_ssh_keys.results is defined

    - name: Configure SSH for long-lived connections
      blockinfile:
        path: /etc/ssh/sshd_config
        marker: "# {mark} ANSIBLE MANAGED BLOCK - Tunnel Configuration"
        block: |
          ClientAliveInterval 60
          ClientAliveCountMax 10
          TCPKeepAlive yes
          MaxSessions 100
          MaxStartups 100:30:200
      notify: restart sshd

    - name: Generate user-specific SSH restrictions block
      template:
        src: ssh_user_restrictions.j2
        dest: /tmp/ssh_user_restrictions.conf
      when: tunnel_users | length > 0

    - name: Restrict user-specific tunnel users
      blockinfile:
        path: /etc/ssh/sshd_config
        marker: "# {mark} ANSIBLE MANAGED BLOCK - User Tunnel Restrictions"
        block: "{{ lookup('file', '/tmp/ssh_user_restrictions.conf') }}"
      notify: restart sshd
      when: tunnel_users | length > 0

    - name: Generate system limits configuration
      template:
        src: system_limits.j2
        dest: /tmp/system_limits.conf

    - name: Configure system limits
      blockinfile:
        path: /etc/security/limits.conf
        marker: "# {mark} ANSIBLE MANAGED BLOCK - Tunnel Limits"
        block: "{{ lookup('file', '/tmp/system_limits.conf') }}"

    - name: Configure sysctl for network tuning
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: yes
      loop:
        - {name: 'fs.file-max', value: '2097152'}
        - {name: 'net.core.somaxconn', value: '4096'}
        - {name: 'net.ipv4.tcp_max_syn_backlog', value: '4096'}
        - {name: 'net.ipv4.ip_local_port_range', value: '1024 65535'}
        - {name: 'net.ipv4.tcp_tw_reuse', value: '1'}
        - {name: 'net.ipv4.tcp_fin_timeout', value: '30'}
        - {name: 'net.ipv4.tcp_keepalive_time', value: '600'}
        - {name: 'net.ipv4.tcp_keepalive_intvl', value: '60'}
        - {name: 'net.ipv4.tcp_keepalive_probes', value: '10'}

    - name: Ensure www root directory exists
      file:
        path: "{{ www_root }}"
        state: directory
        owner: www-data
        group: www-data
        mode: '0755'

    - name: Deploy default index.html for root domain
      copy:
        src: index.html
        dest: "{{ www_root }}/index.html"
        mode: '0644'
        owner: www-data
        group: www-data

    - name: Create user-specific tunnel config directories
      file:
        path: "{{ www_root }}/{{ item }}"
        state: directory
        owner: www-data
        group: www-data
        mode: '0755'
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0

    - name: Create user-specific tunnel configuration files
      template:
        src: user_tunnel_config.yaml.j2
        dest: "{{ www_root }}/{{ item }}/tunnel_config.yaml"
        mode: '0644'
        owner: www-data
        group: www-data
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0

    - name: Check if root SSL certificate exists
      stat:
        path: "{{ ssl_cert_path }}"
      register: ssl_cert_check

    - name: Check user subdomain SSL certificates
      stat:
        path: "/etc/letsencrypt/live/{{ item }}.{{ domain_name }}/fullchain.pem"
      register: user_ssl_checks
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0

    - name: Check custom domain SSL certificates
      stat:
        path: "/etc/letsencrypt/live/{{ item.domain }}/fullchain.pem"
      register: custom_domain_ssl_checks
      loop: "{{ custom_domains }}"
      when: custom_domains | length > 0

    - name: Create nginx configuration for root domain
      template:
        src: nginx-root-domain.conf.j2
        dest: /etc/nginx/sites-available/tunnel-proxy
        mode: '0644'
      vars:
        ssl_enabled: "{{ ssl_cert_check.stat.exists }}"
      notify: reload nginx

    - name: Create nginx configurations for user subdomains
      template:
        src: nginx-user-subdomain.conf.j2
        dest: "/etc/nginx/sites-available/{{ item.item }}-subdomain"
        mode: '0644'
      loop: "{{ user_ssl_checks.results }}"
      vars:
        username: "{{ item.item }}"
        ssl_enabled: "{{ item.stat.exists }}"
      when:
        - tunnel_users | length > 0
        - item.item is defined
      notify: reload nginx

    - name: Create nginx configurations for custom domains
      template:
        src: nginx-custom-domain.conf.j2
        dest: "/etc/nginx/sites-available/{{ item.item.domain | replace('.', '-') }}-custom"
        mode: '0644'
      loop: "{{ custom_domain_ssl_checks.results }}"
      vars:
        custom_domain: "{{ item.item }}"
        ssl_enabled: "{{ item.stat.exists }}"
      when:
        - custom_domains | length > 0
        - item.item is defined
      notify: reload nginx

    - name: Enable root domain nginx site
      file:
        src: /etc/nginx/sites-available/tunnel-proxy
        dest: /etc/nginx/sites-enabled/tunnel-proxy
        state: link
      notify: reload nginx

    - name: Enable user subdomain nginx sites
      file:
        src: "/etc/nginx/sites-available/{{ item }}-subdomain"
        dest: "/etc/nginx/sites-enabled/{{ item }}-subdomain"
        state: link
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0
      notify: reload nginx

    - name: Enable custom domain nginx sites
      file:
        src: "/etc/nginx/sites-available/{{ item.domain | replace('.', '-') }}-custom"
        dest: "/etc/nginx/sites-enabled/{{ item.domain | replace('.', '-') }}-custom"
        state: link
      loop: "{{ custom_domains }}"
      when: custom_domains | length > 0
      notify: reload nginx

    - name: Remove default nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: reload nginx

    - name: Obtain SSL certificate for root domain
      command: >
        certbot --nginx
        --non-interactive
        --agree-tos
        --email {{ letsencrypt_email }}
        -d {{ domain_name }}
      when: not ssl_cert_check.stat.exists
      register: certbot_result
      failed_when: false

    - name: Obtain SSL certificates for user subdomains
      command: >
        certbot --nginx
        --non-interactive
        --agree-tos
        --email {{ letsencrypt_email }}
        -d {{ item.item }}.{{ domain_name }}
      loop: "{{ user_ssl_checks.results }}"
      when:
        - tunnel_users | length > 0
        - item.item is defined
        - not item.stat.exists
      register: user_certbot_results
      failed_when: false

    - name: Obtain SSL certificates for custom domains
      command: >
        certbot --nginx
        --non-interactive
        --agree-tos
        --email {{ letsencrypt_email }}
        -d {{ item.item.domain }}
      loop: "{{ custom_domain_ssl_checks.results }}"
      when:
        - custom_domains | length > 0
        - item.item is defined
        - not item.stat.exists
      register: custom_domain_certbot_results
      failed_when: false

    - name: Re-check root SSL certificate
      stat:
        path: "{{ ssl_cert_path }}"
      register: ssl_cert_recheck
      when: not ssl_cert_check.stat.exists

    - name: Update root nginx with HTTPS support
      template:
        src: nginx-root-domain.conf.j2
        dest: /etc/nginx/sites-available/tunnel-proxy
        mode: '0644'
      vars:
        ssl_enabled: true
      when:
        - not ssl_cert_check.stat.exists
        - ssl_cert_recheck.stat.exists | default(false)
      notify: reload nginx

    - name: Re-check user SSL certificates
      stat:
        path: "/etc/letsencrypt/live/{{ item }}.{{ domain_name }}/fullchain.pem"
      register: user_ssl_rechecks
      loop: "{{ tunnel_users }}"
      when: tunnel_users | length > 0

    - name: Update user nginx with HTTPS support
      template:
        src: nginx-user-subdomain.conf.j2
        dest: "/etc/nginx/sites-available/{{ item.item }}-subdomain"
        mode: '0644'
      loop: "{{ user_ssl_rechecks.results }}"
      vars:
        username: "{{ item.item }}"
        ssl_enabled: "{{ item.stat.exists }}"
      when:
        - tunnel_users | length > 0
        - item.item is defined
        - item.stat.exists | default(false)
      notify: reload nginx

    - name: Re-check custom domain SSL certificates
      stat:
        path: "/etc/letsencrypt/live/{{ item.domain }}/fullchain.pem"
      register: custom_domain_ssl_rechecks
      loop: "{{ custom_domains }}"
      when: custom_domains | length > 0

    - name: Update custom domain nginx with HTTPS support
      template:
        src: nginx-custom-domain.conf.j2
        dest: "/etc/nginx/sites-available/{{ item.item.domain | replace('.', '-') }}-custom"
        mode: '0644'
      loop: "{{ custom_domain_ssl_rechecks.results }}"
      vars:
        custom_domain: "{{ item.item }}"
        ssl_enabled: "{{ item.stat.exists }}"
      when:
        - custom_domains | length > 0
        - item.item is defined
        - item.stat.exists | default(false)
      notify: reload nginx

    - name: Ensure nginx is started and enabled
      service:
        name: nginx
        state: started
        enabled: yes

    - name: Ensure ssh is started and enabled
      service:
        name: ssh
        state: started
        enabled: yes

    - name: Install lsof for socket checking
      apt:
        name: lsof
        state: present

    - name: Deploy socket cleanup script
      copy:
        src: scripts/cleanup-sockets.sh
        dest: /usr/local/bin/cleanup-sockets.sh
        mode: '0755'
        owner: root
        group: root

    - name: Create log file for cleanup script
      file:
        path: /var/log/tunnel-cleanup.log
        state: touch
        mode: '0644'
        owner: root
        group: root
        modification_time: preserve
        access_time: preserve

    - name: Setup cron job for socket cleanup
      cron:
        name: "Cleanup inactive tunnel sockets"
        minute: "*/5"
        job: "/usr/local/bin/cleanup-sockets.sh"
        user: root
        state: present

  handlers:
    - name: restart sshd
      service:
        name: ssh
        state: restarted

    - name: reload nginx
      service:
        name: nginx
        state: reloaded
